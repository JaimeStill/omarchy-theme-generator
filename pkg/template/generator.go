// Package template provides configuration file generation from themes.
// It transforms themes generated by the extraction â†’ synthesis pipeline
// into various configuration file formats for terminal emulators and other applications.
package template

import (
	"context"
	"fmt"
	"io"
	"sync"

	"github.com/JaimeStill/omarchy-theme-generator/pkg/theme"
)

// ConfigGenerator defines the interface for generating configuration files
// from themes. Each generator is responsible for one specific file format.
type ConfigGenerator interface {
	// Generate creates a configuration file as bytes from the given theme
	Generate(ctx context.Context, theme *theme.Theme) ([]byte, error)
	
	// WriteTo writes the configuration directly to the provided writer.
	// This is more efficient than Generate when writing large files.
	WriteTo(ctx context.Context, w io.Writer, theme *theme.Theme) (int64, error)
	
	// Name returns the human-readable name of this generator
	Name() string
	
	// Extension returns the file extension including the dot (e.g., ".toml")
	Extension() string
	
	// Validate performs pre-generation validation of the theme to ensure
	// it contains all required information for this generator type
	Validate(theme *theme.Theme) error
}

// Registry manages multiple configuration generators and enables
// batch generation of all supported formats from a single theme.
type Registry struct {
	mu         sync.RWMutex
	generators map[string]ConfigGenerator
}

// NewRegistry creates a new generator registry with no generators registered.
func NewRegistry() *Registry {
	return &Registry{
		generators: make(map[string]ConfigGenerator),
	}
}

// Register adds a generator to the registry. If a generator with the same
// name already exists, it will be replaced.
func (r *Registry) Register(generator ConfigGenerator) {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.generators[generator.Name()] = generator
}

// Get retrieves a generator by name. Returns nil if not found.
func (r *Registry) Get(name string) ConfigGenerator {
	r.mu.RLock()
	defer r.mu.RUnlock()
	return r.generators[name]
}

// List returns the names of all registered generators.
func (r *Registry) List() []string {
	r.mu.RLock()
	defer r.mu.RUnlock()
	
	names := make([]string, 0, len(r.generators))
	for name := range r.generators {
		names = append(names, name)
	}
	return names
}

// GenerateAll creates configurations for all registered generators.
// Returns a map of filename to generated content.
func (r *Registry) GenerateAll(ctx context.Context, theme *theme.Theme) (map[string][]byte, error) {
	r.mu.RLock()
	generators := make(map[string]ConfigGenerator, len(r.generators))
	for name, gen := range r.generators {
		generators[name] = gen
	}
	r.mu.RUnlock()
	
	results := make(map[string][]byte)
	
	for name, generator := range generators {
		// Validate theme for this generator
		if err := generator.Validate(theme); err != nil {
			return nil, fmt.Errorf("theme validation failed for %s: %w", name, err)
		}
		
		// Generate configuration
		content, err := generator.Generate(ctx, theme)
		if err != nil {
			return nil, fmt.Errorf("generation failed for %s: %w", name, err)
		}
		
		// Create filename
		filename := name + generator.Extension()
		results[filename] = content
	}
	
	return results, nil
}

// GenerationResult contains the result of generating a configuration file
// along with metadata about the generation process.
type GenerationResult struct {
	Filename    string // The generated filename (name + extension)
	Content     []byte // The generated configuration content
	Size        int    // Size in bytes
	Generator   string // Name of the generator used
	Theme       string // Theme name that was used
	GeneratedAt int64  // Unix timestamp of generation
}

// GenerateWithMetadata generates a configuration using the specified generator
// and returns detailed metadata about the result.
func (r *Registry) GenerateWithMetadata(ctx context.Context, generatorName string, theme *theme.Theme) (*GenerationResult, error) {
	generator := r.Get(generatorName)
	if generator == nil {
		return nil, fmt.Errorf("generator %s not found", generatorName)
	}
	
	// Validate theme
	if err := generator.Validate(theme); err != nil {
		return nil, fmt.Errorf("theme validation failed: %w", err)
	}
	
	// Generate content
	content, err := generator.Generate(ctx, theme)
	if err != nil {
		return nil, fmt.Errorf("generation failed: %w", err)
	}
	
	// Create result
	result := &GenerationResult{
		Filename:    generator.Name() + generator.Extension(),
		Content:     content,
		Size:        len(content),
		Generator:   generator.Name(),
		Theme:       theme.Name,
		GeneratedAt: theme.Metadata.Generated.Unix(),
	}
	
	return result, nil
}