package main

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/JaimeStill/omarchy-theme-generator/pkg/extractor"
)

func main() {
	imagesDir := "tests/images"
	
	// Find all image files
	entries, err := os.ReadDir(imagesDir)
	if err != nil {
		fmt.Printf("Error reading directory: %v\n", err)
		return
	}
	
	var images []string
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		name := entry.Name()
		ext := strings.ToLower(filepath.Ext(name))
		if ext == ".jpg" || ext == ".jpeg" || ext == ".png" {
			images = append(images, name)
		}
	}
	
	sort.Strings(images)
	
	// Start building README content
	var readme strings.Builder
	readme.WriteString("# Test Images Characteristics\n\n")
	readme.WriteString("This document provides detailed analysis of all test images used for validating the color extraction strategies.\n\n")
	readme.WriteString("Generated by `go run tests/analyze-images/main.go`\n\n")
	readme.WriteString("## Image Analysis\n\n")
	
	options := extractor.DefaultOptions()
	options.TopColorCount = 5
	
	for _, imageName := range images {
		imagePath := filepath.Join(imagesDir, imageName)
		
		// Load and analyze image
		img, err := extractor.LoadImage(imagePath)
		if err != nil {
			readme.WriteString(fmt.Sprintf("### %s\n\n", imageName))
			readme.WriteString(fmt.Sprintf("**Error loading image**: %v\n\n", err))
			continue
		}
		
		// Get characteristics
		chars := extractor.AnalyzeImageCharacteristics(img)
		
		// Extract colors to see strategy selection
		result, err := extractor.ExtractColors(imagePath, options)
		if err != nil {
			readme.WriteString(fmt.Sprintf("### %s\n\n", imageName))
			readme.WriteString(fmt.Sprintf("**Error extracting colors**: %v\n\n", err))
			continue
		}
		
		analysis := result.AnalyzeForThemeGeneration()
		
		// Write image section
		readme.WriteString(fmt.Sprintf("### %s\n\n", imageName))
		
		// Dimensions
		bounds := img.Bounds()
		readme.WriteString(fmt.Sprintf("**Dimensions**: %d x %d pixels\n\n", bounds.Dx(), bounds.Dy()))
		
		// Characteristics table
		readme.WriteString("#### Characteristics\n\n")
		readme.WriteString("| Property | Value | Description |\n")
		readme.WriteString("|----------|-------|-------------|\n")
		readme.WriteString(fmt.Sprintf("| Image Type | `%s` | %s |\n", 
			getImageTypeName(chars.Type),
			getImageTypeDescription(chars.Type)))
		readme.WriteString(fmt.Sprintf("| Edge Density | %.4f | %s |\n", 
			chars.EdgeDensity,
			getEdgeDensityDescription(chars.EdgeDensity)))
		readme.WriteString(fmt.Sprintf("| Color Complexity | %d colors | %s |\n", 
			chars.ColorComplexity,
			getComplexityDescription(chars.ColorComplexity)))
		readme.WriteString(fmt.Sprintf("| Contrast Level | %.4f | %s |\n", 
			chars.ContrastLevel,
			getContrastDescription(chars.ContrastLevel)))
		readme.WriteString(fmt.Sprintf("| Average Saturation | %.4f | %s |\n", 
			chars.AverageSaturation,
			getSaturationDescription(chars.AverageSaturation)))
		readme.WriteString(fmt.Sprintf("| Dominance Pattern | %.2f%% | %s |\n", 
			chars.DominancePattern*100,
			getDominanceDescription(chars.DominancePattern)))
		readme.WriteString(fmt.Sprintf("| Has Distinct Regions | %v | %s |\n", 
			chars.HasDistinctRegions,
			getRegionDescription(chars.HasDistinctRegions)))
		
		// Strategy selection
		readme.WriteString("\n#### Strategy Selection\n\n")
		
		// Check what strategies can handle this
		canHandleSaliency := chars.Type == extractor.HighDetail || chars.EdgeDensity > 0.1
		saliencyPriority := getSaliencyPriority(chars)
		frequencyPriority := getFrequencyPriority(chars)
		
		readme.WriteString(fmt.Sprintf("- **Selected Strategy**: `%s`\n", result.SelectedStrategy))
		readme.WriteString(fmt.Sprintf("- **Saliency Can Handle**: %v (HighDetail=%v OR EdgeDensity>0.1=%v)\n", 
			canHandleSaliency, 
			chars.Type == extractor.HighDetail,
			chars.EdgeDensity > 0.1))
		readme.WriteString(fmt.Sprintf("- **Saliency Priority**: %d\n", saliencyPriority))
		readme.WriteString(fmt.Sprintf("- **Frequency Priority**: %d (fallback, always handles)\n", frequencyPriority))
		
		// Color extraction results
		readme.WriteString("\n#### Extraction Results\n\n")
		readme.WriteString(fmt.Sprintf("- **Unique Colors**: %d\n", result.UniqueColors))
		readme.WriteString(fmt.Sprintf("- **Dominant Color**: `%s` (%.2f%%)\n", 
			result.DominantColor.HEX(), 
			result.TopColors[0].Percentage))
		
		// Theme generation analysis
		readme.WriteString("\n#### Theme Generation Analysis\n\n")
		readme.WriteString(fmt.Sprintf("- **Suggested Strategy**: %s\n", analysis.SuggestedStrategy))
		readme.WriteString(fmt.Sprintf("- **Is Grayscale**: %v\n", analysis.IsGrayscale))
		readme.WriteString(fmt.Sprintf("- **Is Monochromatic**: %v\n", analysis.IsMonochromatic))
		if !analysis.IsGrayscale && analysis.IsMonochromatic {
			readme.WriteString(fmt.Sprintf("- **Dominant Hue**: %.1f°\n", analysis.DominantHue))
		}
		
		// Top colors palette
		readme.WriteString("\n#### Top 5 Colors\n\n")
		readme.WriteString("| Rank | Color | Hex | Percentage |\n")
		readme.WriteString("|------|-------|-----|------------|\n")
		for i, cf := range result.TopColors {
			if i >= 5 {
				break
			}
			_, s, l := cf.Color.HSL()
			colorType := getColorType(s, l)
			readme.WriteString(fmt.Sprintf("| %d | %s | `%s` | %.2f%% |\n", 
				i+1, colorType, cf.Color.HEX(), cf.Percentage))
		}
		
		readme.WriteString("\n---\n\n")
	}
	
	// Write README file
	readmePath := filepath.Join(imagesDir, "README.md")
	err = os.WriteFile(readmePath, []byte(readme.String()), 0644)
	if err != nil {
		fmt.Printf("Error writing README: %v\n", err)
		return
	}
	
	fmt.Printf("✅ Generated %s with analysis of %d images\n", readmePath, len(images))
}

func getImageTypeName(t extractor.ImageType) string {
	switch t {
	case extractor.HighDetail:
		return "HighDetail"
	case extractor.LowDetail:
		return "LowDetail"
	case extractor.Smooth:
		return "Smooth"
	case extractor.Complex:
		return "Complex"
	default:
		return "Unknown"
	}
}

func getImageTypeDescription(t extractor.ImageType) string {
	switch t {
	case extractor.HighDetail:
		return "Many edges and fine details"
	case extractor.LowDetail:
		return "Few distinct features"
	case extractor.Smooth:
		return "Gradual transitions, many colors"
	case extractor.Complex:
		return "Rich in both colors and edges"
	default:
		return "Unclassified"
	}
}

func getEdgeDensityDescription(density float64) string {
	if density > 0.15 {
		return "Very high edge content"
	} else if density > 0.1 {
		return "High edge content"
	} else if density > 0.05 {
		return "Moderate edges"
	} else {
		return "Minimal edges"
	}
}

func getComplexityDescription(colors int) string {
	if colors > 10000 {
		return "Extremely diverse palette"
	} else if colors > 1000 {
		return "Very diverse palette"
	} else if colors > 100 {
		return "Moderate diversity"
	} else {
		return "Limited palette"
	}
}

func getContrastDescription(contrast float64) string {
	if contrast > 0.3 {
		return "Very high contrast"
	} else if contrast > 0.2 {
		return "High contrast"
	} else if contrast > 0.1 {
		return "Moderate contrast"
	} else {
		return "Low contrast"
	}
}

func getSaturationDescription(sat float64) string {
	if sat < 0.05 {
		return "Grayscale/desaturated"
	} else if sat < 0.2 {
		return "Low saturation"
	} else if sat < 0.5 {
		return "Moderate saturation"
	} else {
		return "High saturation"
	}
}

func getDominanceDescription(dom float64) string {
	if dom > 0.5 {
		return "Single color dominates"
	} else if dom > 0.2 {
		return "Strong primary color"
	} else if dom > 0.05 {
		return "Balanced distribution"
	} else {
		return "Highly distributed"
	}
}

func getRegionDescription(hasRegions bool) string {
	if hasRegions {
		return "Clear visual boundaries"
	}
	return "Uniform or gradient"
}

func getSaliencyPriority(chars *extractor.ImageCharacteristics) int {
	switch chars.Type {
	case extractor.HighDetail:
		return 100
	case extractor.Complex:
		return 80
	default:
		return 10
	}
}

func getFrequencyPriority(chars *extractor.ImageCharacteristics) int {
	switch chars.Type {
	case extractor.LowDetail:
		return 100
	case extractor.Smooth:
		if chars.ColorComplexity < 50 {
			return 80
		}
		return 30
	case extractor.HighDetail:
		return 20
	case extractor.Complex:
		return 25
	default:
		return 50
	}
}

func getColorType(s, l float64) string {
	if s < 0.05 {
		if l < 0.2 {
			return "Black"
		} else if l > 0.8 {
			return "White"
		} else {
			return "Gray"
		}
	} else if s < 0.3 {
		return "Muted"
	} else {
		return "Vibrant"
	}
}