package main

import (
	"context"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/JaimeStill/omarchy-theme-generator/pkg/formats"
	"github.com/JaimeStill/omarchy-theme-generator/pkg/loader"
	"github.com/JaimeStill/omarchy-theme-generator/pkg/processor"
	"github.com/JaimeStill/omarchy-theme-generator/pkg/settings"
)

func main() {
	// Parse command line flags
	imagesDir := flag.String("images", "tests/images", "Directory containing test images")
	showCandidates := flag.Bool("candidates", true, "Show detailed candidate colors")
	maxCandidatesShown := flag.Int("max-candidates", 3, "Maximum candidates to show per category")
	flag.Parse()

	// Find all image files
	entries, err := os.ReadDir(*imagesDir)
	if err != nil {
		fmt.Printf("Error reading directory: %v\n", err)
		return
	}

	var images []string
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		name := entry.Name()
		ext := strings.ToLower(filepath.Ext(name))
		if ext == ".jpg" || ext == ".jpeg" || ext == ".png" {
			images = append(images, name)
		}
	}

	sort.Strings(images)

	// Initialize processor
	s := settings.DefaultSettings()
	p := processor.New(s)
	l := loader.NewFileLoader(s)
	ctx := context.Background()

	// Start building README content
	var readme strings.Builder
	readme.WriteString("# Test Images Analysis\n\n")
	readme.WriteString("This document provides detailed color analysis of all test images using the characteristic-based color pool system. ")
	readme.WriteString("Each image is processed through the color extraction pipeline with frequency weighting and characteristic grouping.\n\n")
	readme.WriteString("Generated by `go run tools/analyze-images/main.go`\n\n")

	for _, imageName := range images {
		imagePath := filepath.Join(*imagesDir, imageName)

		// Load image
		img, err := l.LoadImage(ctx, imagePath)
		if err != nil {
			readme.WriteString(fmt.Sprintf("## %s\n\n", imageName))
			readme.WriteString(fmt.Sprintf("**Error loading image**: %v\n\n", err))
			continue
		}

		// Get image info
		info, err := l.GetImageInfo(ctx, imagePath)
		if err != nil {
			readme.WriteString(fmt.Sprintf("## %s\n\n", imageName))
			readme.WriteString(fmt.Sprintf("**Error getting image info**: %v\n\n", err))
			continue
		}

		// Process image for complete analysis
		profile, err := p.ProcessImage(img)
		if err != nil {
			readme.WriteString(fmt.Sprintf("## %s\n\n", imageName))
			readme.WriteString(fmt.Sprintf("**Error processing image**: %v\n\n", err))
			continue
		}

		// Write image section header
		readme.WriteString(fmt.Sprintf("## %s\n\n", imageName))
		readme.WriteString(fmt.Sprintf("![%s](./%s)\n\n", imageName, imageName))
		readme.WriteString(fmt.Sprintf("**Dimensions**: %d x %d px\n\n", info.Width, info.Height))

		// Color palette showcase
		writeColorPalette(&readme, profile)

		// Profile summary
		writeProfileSummary(&readme, profile)

		// Statistical analysis
		writeStatisticalMetrics(&readme, profile)

		// Detailed breakdown if enabled
		if *showCandidates {
			writeCharacteristicBreakdown(&readme, profile, *maxCandidatesShown)
		}
	}

	// Write README to tests/images/README.md
	outputPath := filepath.Join(*imagesDir, "README.md")
	err = os.WriteFile(outputPath, []byte(readme.String()), 0644)
	if err != nil {
		fmt.Printf("Error writing README: %v\n", err)
		return
	}

	fmt.Printf("Successfully analyzed %d images and wrote README to %s\n", len(images), outputPath)
}

// writeColorPalette creates a clean color palette showcase
func writeColorPalette(readme *strings.Builder, profile *processor.ColorProfile) {
	readme.WriteString("### Color Palette\n\n")

	// Show color clusters in a clean grid
	if len(profile.Colors) > 0 {
		readme.WriteString("**Color Clusters**\n\n")
		maxColors := 12 // Show top 12 colors in a nice grid
		if maxColors > len(profile.Colors) {
			maxColors = len(profile.Colors)
		}

		// Create a visual grid of color swatches
		for i := 0; i < maxColors; i++ {
			cluster := profile.Colors[i]
			hex := formats.ToHex(cluster.RGBA)
			visual := renderColorSwatch(hex)
			readme.WriteString(visual + " ")

			// Add line break every 6 colors for clean grid
			if (i+1)%6 == 0 {
				readme.WriteString("\n")
			}
		}
		readme.WriteString("\n\n")

		// Color details table
		readme.WriteString("| Color | Hex | Weight | Lightness | Characteristics |\n")
		readme.WriteString("|-------|-----|--------|-----------|----------------|\n")
		for i := 0; i < maxColors; i++ {
			cluster := profile.Colors[i]
			hex := formats.ToHex(cluster.RGBA)
			visual := renderColorSwatch(hex)
			characteristics := getCharacteristics(cluster)
			readme.WriteString(fmt.Sprintf("| %s | `%s` | %.4f | %.3f | %s |\n",
				visual, hex, cluster.Weight, cluster.Lightness, characteristics))
		}
		readme.WriteString("\n")
	}
}

func writeLightnessGroups(readme *strings.Builder, profile *processor.ColorProfile) {
	readme.WriteString("#### Lightness Groups\n\n")
	readme.WriteString("| Group | Count | Colors |\n")
	readme.WriteString("|-------|--------|--------|\n")

	var darkColors, midColors, lightColors []processor.ColorCluster
	for _, cluster := range profile.Colors {
		if cluster.IsDark {
			darkColors = append(darkColors, cluster)
		} else if cluster.IsLight {
			lightColors = append(lightColors, cluster)
		} else {
			midColors = append(midColors, cluster)
		}
	}

	if len(darkColors) > 0 {
		colors := formatClusterList(darkColors, 5)
		readme.WriteString(fmt.Sprintf("| Dark | %d | %s |\n", len(darkColors), colors))
	}

	if len(midColors) > 0 {
		colors := formatClusterList(midColors, 5)
		readme.WriteString(fmt.Sprintf("| Mid | %d | %s |\n", len(midColors), colors))
	}

	if len(lightColors) > 0 {
		colors := formatClusterList(lightColors, 5)
		readme.WriteString(fmt.Sprintf("| Light | %d | %s |\n", len(lightColors), colors))
	}

	readme.WriteString("\n")
}

func writeSaturationGroups(readme *strings.Builder, profile *processor.ColorProfile) {
	readme.WriteString("#### Saturation Groups\n\n")
	readme.WriteString("| Group | Count | Colors |\n")
	readme.WriteString("|-------|--------|--------|\n")

	var neutralColors, mutedColors, normalColors, vibrantColors []processor.ColorCluster
	for _, cluster := range profile.Colors {
		if cluster.IsNeutral {
			neutralColors = append(neutralColors, cluster)
		} else if cluster.IsMuted {
			mutedColors = append(mutedColors, cluster)
		} else if cluster.IsVibrant {
			vibrantColors = append(vibrantColors, cluster)
		} else {
			normalColors = append(normalColors, cluster)
		}
	}

	if len(neutralColors) > 0 {
		colors := formatClusterList(neutralColors, 5)
		readme.WriteString(fmt.Sprintf("| Neutral | %d | %s |\n", len(neutralColors), colors))
	}

	if len(mutedColors) > 0 {
		colors := formatClusterList(mutedColors, 5)
		readme.WriteString(fmt.Sprintf("| Muted | %d | %s |\n", len(mutedColors), colors))
	}

	if len(normalColors) > 0 {
		colors := formatClusterList(normalColors, 5)
		readme.WriteString(fmt.Sprintf("| Normal | %d | %s |\n", len(normalColors), colors))
	}

	if len(vibrantColors) > 0 {
		colors := formatClusterList(vibrantColors, 5)
		readme.WriteString(fmt.Sprintf("| Vibrant | %d | %s |\n", len(vibrantColors), colors))
	}

	readme.WriteString("\n")
}

func writeHueFamilies(readme *strings.Builder, profile *processor.ColorProfile) {
	if len(profile.Colors) == 0 {
		return
	}

	readme.WriteString("#### Hue Distribution\n\n")
	readme.WriteString("| Hue Range | Count | Colors |\n")
	readme.WriteString("|-----------|--------|--------|\n")

	// Group colors by 60-degree hue ranges
	hueFamilies := make(map[int][]processor.ColorCluster)
	for _, cluster := range profile.Colors {
		if !cluster.IsNeutral { // Only include colored clusters
			hueRange := int(cluster.Hue) / 60
			hueFamilies[hueRange] = append(hueFamilies[hueRange], cluster)
		}
	}

	for sector := 0; sector < 6; sector++ {
		if colors, exists := hueFamilies[sector]; exists && len(colors) > 0 {
			hueStart := float64(sector) * 60.0
			hueEnd := hueStart + 60.0
			colorList := formatClusterList(colors, 5)
			readme.WriteString(fmt.Sprintf("| %.0f°-%.0f° | %d | %s |\n", hueStart, hueEnd, len(colors), colorList))
		}
	}

	readme.WriteString("\n")
}

func writeColorClusters(readme *strings.Builder, clusters []processor.ColorCluster) {
	if len(clusters) == 0 {
		return
	}

	readme.WriteString("#### Color Clusters\n\n")
	readme.WriteString("| Rank | Hex | Visual | Weight | Characteristics |\n")
	readme.WriteString("|------|-----|--------|--------|----------------|\n")

	for i, cluster := range clusters {
		if i >= 10 { // Show top 10
			break
		}
		hex := formats.ToHex(cluster.RGBA)
		visual := renderColorBlock(hex)
		characteristics := getCharacteristics(cluster)
		readme.WriteString(fmt.Sprintf("| %d | `%s` | %s | %.4f | %s |\n",
			i+1, hex, visual, cluster.Weight, characteristics))
	}

	if len(clusters) > 10 {
		readme.WriteString(fmt.Sprintf("| ... | +%d more | | | |\n", len(clusters)-10))
	}

	readme.WriteString("\n")
}

func formatClusterList(clusters []processor.ColorCluster, maxShow int) string {
	if len(clusters) == 0 {
		return "-"
	}

	var result strings.Builder
	for i, cluster := range clusters {
		if i >= maxShow {
			if len(clusters) > maxShow {
				result.WriteString(fmt.Sprintf(" +%d more", len(clusters)-maxShow))
			}
			break
		}
		if i > 0 {
			result.WriteString(" ")
		}
		hex := formats.ToHex(cluster.RGBA)
		visual := renderColorBlock(hex)
		result.WriteString(visual)
	}
	return result.String()
}

// writeDetailedColorBreakdown adds a detailed section showing all color clusters
func writeDetailedColorBreakdown(readme *strings.Builder, profile *processor.ColorProfile, maxColorsShown int) {
	readme.WriteString("### Detailed Color Breakdown\n\n")

	// Show all color clusters with their characteristics
	if len(profile.Colors) > 0 {
		readme.WriteString("#### All Color Clusters\n\n")
		readme.WriteString("| Rank | Hex | Visual | Weight | Lightness | Saturation | Hue | Characteristics |\n")
		readme.WriteString("|------|-----|--------|--------|-----------|------------|-----|----------------|\n")

		maxShow := len(profile.Colors) // Show all clusters
		if maxColorsShown > 0 && maxColorsShown < maxShow {
			maxShow = maxColorsShown
		}

		for i := 0; i < maxShow; i++ {
			cluster := profile.Colors[i]
			hex := formats.ToHex(cluster.RGBA)
			visual := renderColorBlock(hex)
			characteristics := getCharacteristics(cluster)

			readme.WriteString(fmt.Sprintf("| %d | `%s` | %s | %.4f | %.3f | %.3f | %.0f° | %s |\n",
				i+1, hex, visual, cluster.Weight, cluster.Lightness, cluster.Saturation, cluster.Hue, characteristics))
		}

		if len(profile.Colors) > maxShow {
			readme.WriteString(fmt.Sprintf("| ... | +%d more | | | | | | |\n", len(profile.Colors)-maxShow))
		}

		readme.WriteString("\n")
	}
}

// writeStatisticalMetrics shows key metrics in a compact format
func writeStatisticalMetrics(readme *strings.Builder, profile *processor.ColorProfile) {
	readme.WriteString("### Analysis Metrics\n\n")

	// Calculate characteristics distribution
	var darkColors, lightColors, neutralColors, vibrantColors int
	var totalWeight float64
	var avgHue, avgSaturation, avgLightness float64

	for _, cluster := range profile.Colors {
		if cluster.IsDark {
			darkColors++
		}
		if cluster.IsLight {
			lightColors++
		}
		if cluster.IsNeutral {
			neutralColors++
		}
		if cluster.IsVibrant {
			vibrantColors++
		}
		totalWeight += cluster.Weight
		avgHue += cluster.Hue * cluster.Weight
		avgSaturation += cluster.Saturation * cluster.Weight
		avgLightness += cluster.Lightness * cluster.Weight
	}

	if totalWeight > 0 {
		avgHue /= totalWeight
		avgSaturation /= totalWeight
		avgLightness /= totalWeight
	}

	// Create two-column layout for better space usage
	readme.WriteString("| Property | Value | Property | Value |\n")
	readme.WriteString("|----------|-------|----------|-------|\n")

	readme.WriteString(fmt.Sprintf("| **Color Count** | %d | **Has Color** | %t |\n",
		profile.ColorCount, profile.HasColor))
	readme.WriteString(fmt.Sprintf("| **Dark Colors** | %d | **Light Colors** | %d |\n",
		darkColors, lightColors))
	readme.WriteString(fmt.Sprintf("| **Neutral Colors** | %d | **Vibrant Colors** | %d |\n",
		neutralColors, vibrantColors))
	readme.WriteString(fmt.Sprintf("| **Avg Hue** | %.0f° | **Avg Saturation** | %.3f |\n",
		avgHue, avgSaturation))
	readme.WriteString(fmt.Sprintf("| **Avg Lightness** | %.3f | **Theme Mode** | %s |\n",
		avgLightness, profile.Mode))

	readme.WriteString("\n")
}

// Removed writeProfileAnalysis - replaced by writeProfileSummary and writeStatisticalMetrics

// writeProfileSummary creates a concise profile overview
func writeProfileSummary(readme *strings.Builder, profile *processor.ColorProfile) {
	readme.WriteString("### Profile Overview\n\n")
	readme.WriteString("| Property | Value |\n")
	readme.WriteString("|----------|-------|\n")
	readme.WriteString(fmt.Sprintf("| **Theme Mode** | %s |\n", profile.Mode))
	readme.WriteString(fmt.Sprintf("| **Color Count** | %d |\n", profile.ColorCount))
	readme.WriteString(fmt.Sprintf("| **Has Color** | %t |\n", profile.HasColor))
	readme.WriteString(fmt.Sprintf("| **Total Clusters** | %d |\n", len(profile.Colors)))

	if len(profile.Colors) > 0 {
		topColor := profile.Colors[0]
		hex := formats.ToHex(topColor.RGBA)
		visual := renderColorBlock(hex)
		readme.WriteString(fmt.Sprintf("| **Top Color** | %s `%s` (%.1f%%) |\n",
			visual, hex, topColor.Weight*100))
	}
	readme.WriteString("\n")
}

// writeCharacteristicBreakdown shows detailed color organization
func writeCharacteristicBreakdown(readme *strings.Builder, profile *processor.ColorProfile, maxShown int) {
	readme.WriteString("### Characteristic Breakdown\n\n")

	// Lightness distribution
	writeLightnessGroups(readme, profile)

	// Saturation distribution
	writeSaturationGroups(readme, profile)

	// Hue families
	writeHueFamilies(readme, profile)

	// Color clusters
	writeColorClusters(readme, profile.Colors)

	// Detailed color breakdown if requested
	writeDetailedColorBreakdown(readme, profile, maxShown)
}

// renderColorSwatch creates a compact color swatch for grid display
func renderColorSwatch(hexColor string) string {
	// Remove # prefix if present for URL formatting
	cleanHex := strings.TrimPrefix(hexColor, "#")

	// Validate hex format
	if len(cleanHex) != 6 {
		return "![invalid](https://placehold.co/20x20/cccccc/cccccc.png)"
	}

	// Return markdown image tag with placehold.co URL for small swatches
	return fmt.Sprintf("![%s](https://placehold.co/20x20/%s/%s.png)", hexColor, cleanHex, cleanHex)
}

// renderColorBlock creates an image tag for color preview using placehold.co
func renderColorBlock(hexColor string) string {
	// Remove # prefix if present for URL formatting
	cleanHex := strings.TrimPrefix(hexColor, "#")

	// Validate hex format
	if len(cleanHex) != 6 {
		return "![invalid](https://placehold.co/30x30/cccccc/cccccc.png)"
	}

	// Return markdown image tag with placehold.co URL
	return fmt.Sprintf("![%s](https://placehold.co/30x30/%s/%s.png)", hexColor, cleanHex, cleanHex)
}

// getCharacteristics returns a string describing the color cluster's characteristics
func getCharacteristics(cluster processor.ColorCluster) string {
	var characteristics []string

	if cluster.IsDark {
		characteristics = append(characteristics, "Dark")
	}
	if cluster.IsLight {
		characteristics = append(characteristics, "Light")
	}
	if cluster.IsNeutral {
		characteristics = append(characteristics, "Neutral")
	}
	if cluster.IsMuted {
		characteristics = append(characteristics, "Muted")
	}
	if cluster.IsVibrant {
		characteristics = append(characteristics, "Vibrant")
	}

	if len(characteristics) == 0 {
		return "Normal"
	}

	return strings.Join(characteristics, ", ")
}
