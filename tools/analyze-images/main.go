package main

import (
	"context"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/JaimeStill/omarchy-theme-generator/pkg/formats"
	"github.com/JaimeStill/omarchy-theme-generator/pkg/loader"
	"github.com/JaimeStill/omarchy-theme-generator/pkg/processor"
	"github.com/JaimeStill/omarchy-theme-generator/pkg/settings"
)

func main() {
	// Parse command line flags
	imagesDir := flag.String("images", "tests/images", "Directory containing test images")
	showCandidates := flag.Bool("candidates", true, "Show detailed candidate colors")
	maxCandidatesShown := flag.Int("max-candidates", 3, "Maximum candidates to show per category")
	flag.Parse()

	// Find all image files
	entries, err := os.ReadDir(*imagesDir)
	if err != nil {
		fmt.Printf("Error reading directory: %v\n", err)
		return
	}

	var images []string
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		name := entry.Name()
		ext := strings.ToLower(filepath.Ext(name))
		if ext == ".jpg" || ext == ".jpeg" || ext == ".png" {
			images = append(images, name)
		}
	}

	sort.Strings(images)

	// Initialize processor
	s := settings.DefaultSettings()
	p := processor.New(s)
	l := loader.NewFileLoader(s)
	ctx := context.Background()

	// Start building README content
	var readme strings.Builder
	readme.WriteString("# Test Images Analysis\n\n")
	readme.WriteString("This document provides detailed color analysis of all test images using the characteristic-based color pool system. ")
	readme.WriteString("Each image is processed through the color extraction pipeline with frequency weighting and characteristic grouping.\n\n")
	readme.WriteString("Generated by `go run tools/analyze-images/main.go`\n\n")

	for _, imageName := range images {
		imagePath := filepath.Join(*imagesDir, imageName)

		// Load image
		img, err := l.LoadImage(ctx, imagePath)
		if err != nil {
			readme.WriteString(fmt.Sprintf("## %s\n\n", imageName))
			readme.WriteString(fmt.Sprintf("**Error loading image**: %v\n\n", err))
			continue
		}

		// Get image info
		info, err := l.GetImageInfo(ctx, imagePath)
		if err != nil {
			readme.WriteString(fmt.Sprintf("## %s\n\n", imageName))
			readme.WriteString(fmt.Sprintf("**Error getting image info**: %v\n\n", err))
			continue
		}

		// Process image for complete analysis
		profile, err := p.ProcessImage(img)
		if err != nil {
			readme.WriteString(fmt.Sprintf("## %s\n\n", imageName))
			readme.WriteString(fmt.Sprintf("**Error processing image**: %v\n\n", err))
			continue
		}

		// Write image section header
		readme.WriteString(fmt.Sprintf("## %s\n\n", imageName))
		readme.WriteString(fmt.Sprintf("![%s](./%s)\n\n", imageName, imageName))
		readme.WriteString(fmt.Sprintf("**Dimensions**: %d x %d px\n\n", info.Width, info.Height))

		// Color palette showcase
		writeColorPalette(&readme, profile)

		// Profile summary
		writeProfileSummary(&readme, profile)

		// Statistical analysis
		writeStatisticalMetrics(&readme, profile)

		// Detailed breakdown if enabled
		if *showCandidates {
			writeCharacteristicBreakdown(&readme, profile, *maxCandidatesShown)
		}
	}

	// Write README to tests/images/README.md
	outputPath := filepath.Join(*imagesDir, "README.md")
	err = os.WriteFile(outputPath, []byte(readme.String()), 0644)
	if err != nil {
		fmt.Printf("Error writing README: %v\n", err)
		return
	}

	fmt.Printf("Successfully analyzed %d images and wrote README to %s\n", len(images), outputPath)
}

// writeColorPalette creates a clean color palette showcase
func writeColorPalette(readme *strings.Builder, profile *processor.ColorProfile) {
	readme.WriteString("### Color Palette\n\n")
	
	// Show dominant colors in a clean grid
	if len(profile.Pool.DominantColors) > 0 {
		readme.WriteString("**Dominant Colors**\n\n")
		maxColors := 12 // Show top 12 colors in a nice grid
		if maxColors > len(profile.Pool.DominantColors) {
			maxColors = len(profile.Pool.DominantColors)
		}
		
		// Create a visual grid of color swatches
		for i := 0; i < maxColors; i++ {
			wc := profile.Pool.DominantColors[i]
			hex := formats.ToHex(wc.RGBA)
			visual := renderColorSwatch(hex)
			readme.WriteString(visual + " ")
			
			// Add line break every 6 colors for clean grid
			if (i+1)%6 == 0 {
				readme.WriteString("\n")
			}
		}
		readme.WriteString("\n\n")
		
		// Color details table
		readme.WriteString("| Color | Hex | Frequency | Weight |\n")
		readme.WriteString("|-------|-----|-----------|--------|\n")
		for i := 0; i < maxColors; i++ {
			wc := profile.Pool.DominantColors[i]
			hex := formats.ToHex(wc.RGBA)
			visual := renderColorSwatch(hex)
			readme.WriteString(fmt.Sprintf("| %s | `%s` | %d | %.4f |\n",
				visual, hex, wc.Frequency, wc.Weight))
		}
		readme.WriteString("\n")
	}
}

func writeLightnessGroups(readme *strings.Builder, groups processor.LightnessGroups) {
	readme.WriteString("#### Lightness Groups\n\n")
	readme.WriteString("| Group | Count | Colors |\n")
	readme.WriteString("|-------|--------|--------|\n")

	if len(groups.Dark) > 0 {
		colors := formatColorList(groups.Dark, 5)
		readme.WriteString(fmt.Sprintf("| Dark | %d | %s |\n", len(groups.Dark), colors))
	}

	if len(groups.Mid) > 0 {
		colors := formatColorList(groups.Mid, 5)
		readme.WriteString(fmt.Sprintf("| Mid | %d | %s |\n", len(groups.Mid), colors))
	}

	if len(groups.Light) > 0 {
		colors := formatColorList(groups.Light, 5)
		readme.WriteString(fmt.Sprintf("| Light | %d | %s |\n", len(groups.Light), colors))
	}

	readme.WriteString("\n")
}

func writeSaturationGroups(readme *strings.Builder, groups processor.SaturationGroups) {
	readme.WriteString("#### Saturation Groups\n\n")
	readme.WriteString("| Group | Count | Colors |\n")
	readme.WriteString("|-------|--------|--------|\n")

	if len(groups.Gray) > 0 {
		colors := formatColorList(groups.Gray, 5)
		readme.WriteString(fmt.Sprintf("| Gray | %d | %s |\n", len(groups.Gray), colors))
	}

	if len(groups.Muted) > 0 {
		colors := formatColorList(groups.Muted, 5)
		readme.WriteString(fmt.Sprintf("| Muted | %d | %s |\n", len(groups.Muted), colors))
	}

	if len(groups.Normal) > 0 {
		colors := formatColorList(groups.Normal, 5)
		readme.WriteString(fmt.Sprintf("| Normal | %d | %s |\n", len(groups.Normal), colors))
	}

	if len(groups.Vibrant) > 0 {
		colors := formatColorList(groups.Vibrant, 5)
		readme.WriteString(fmt.Sprintf("| Vibrant | %d | %s |\n", len(groups.Vibrant), colors))
	}

	readme.WriteString("\n")
}

func writeHueFamilies(readme *strings.Builder, families processor.HueFamilies) {
	if len(families) == 0 {
		return
	}

	readme.WriteString("#### Hue Families\n\n")
	readme.WriteString("| Hue Range | Count | Colors |\n")
	readme.WriteString("|-----------|--------|--------|\n")

	for sector, colors := range families {
		if len(colors) > 0 {
			hueStart := float64(sector) * 30.0
			hueEnd := hueStart + 30.0
			colorList := formatColorList(colors, 5)
			readme.WriteString(fmt.Sprintf("| %.0f°-%.0f° | %d | %s |\n", hueStart, hueEnd, len(colors), colorList))
		}
	}

	readme.WriteString("\n")
}

func writeDominantColors(readme *strings.Builder, dominantColors []processor.WeightedColor) {
	if len(dominantColors) == 0 {
		return
	}

	readme.WriteString("#### Dominant Colors\n\n")
	readme.WriteString("| Rank | Hex | Visual | Frequency | Weight |\n")
	readme.WriteString("|------|-----|--------|-----------|--------|\n")

	for i, wc := range dominantColors {
		if i >= 10 { // Show top 10
			break
		}
		hex := formats.ToHex(wc.RGBA)
		visual := renderColorBlock(hex)
		readme.WriteString(fmt.Sprintf("| %d | `%s` | %s | %d | %.4f |\n",
			i+1, hex, visual, wc.Frequency, wc.Weight))
	}

	if len(dominantColors) > 10 {
		readme.WriteString(fmt.Sprintf("| ... | +%d more | | | |\n", len(dominantColors)-10))
	}

	readme.WriteString("\n")
}

func formatColorList(colors []processor.WeightedColor, maxShow int) string {
	if len(colors) == 0 {
		return "-"
	}

	var result strings.Builder
	for i, wc := range colors {
		if i >= maxShow {
			if len(colors) > maxShow {
				result.WriteString(fmt.Sprintf(" +%d more", len(colors)-maxShow))
			}
			break
		}
		if i > 0 {
			result.WriteString(" ")
		}
		hex := formats.ToHex(wc.RGBA)
		visual := renderColorBlock(hex)
		result.WriteString(visual)
	}
	return result.String()
}

// writeDetailedColorBreakdown adds a detailed section showing all colors by characteristic groups
func writeDetailedColorBreakdown(readme *strings.Builder, profile *processor.ColorProfile, maxColorsShown int) {
	readme.WriteString("### Detailed Color Breakdown\n\n")

	// Show all colors in each group with their weights and frequencies
	if len(profile.Pool.AllColors) > 0 {
		readme.WriteString("#### All Extracted Colors\n\n")
		readme.WriteString("| Rank | Hex | Visual | Frequency | Weight | Lightness | Saturation |\n")
		readme.WriteString("|------|-----|--------|-----------|--------|-----------|------------|\n")

		maxShow := maxColorsShown * 3 // Show more colors in detail
		if maxShow > len(profile.Pool.AllColors) {
			maxShow = len(profile.Pool.AllColors)
		}

		for i := 0; i < maxShow; i++ {
			wc := profile.Pool.AllColors[i]
			hex := formats.ToHex(wc.RGBA)
			visual := renderColorBlock(hex)
			hsla := formats.RGBAToHSLA(wc.RGBA)

			readme.WriteString(fmt.Sprintf("| %d | `%s` | %s | %d | %.4f | %.3f | %.3f |\n",
				i+1, hex, visual, wc.Frequency, wc.Weight, hsla.L, hsla.S))
		}

		if len(profile.Pool.AllColors) > maxShow {
			readme.WriteString(fmt.Sprintf("| ... | +%d more | | | | | |\n", len(profile.Pool.AllColors)-maxShow))
		}

		readme.WriteString("\n")
	}
}

// writeStatisticalMetrics shows key metrics in a compact format
func writeStatisticalMetrics(readme *strings.Builder, profile *processor.ColorProfile) {
	readme.WriteString("### Analysis Metrics\n\n")
	
	// Create two-column layout for better space usage
	readme.WriteString("| Property | Value | Property | Value |\n")
	readme.WriteString("|----------|-------|----------|-------|\n")
	
	stats := profile.Pool.Statistics
	readme.WriteString(fmt.Sprintf("| **Chromatic Diversity** | %.3f | **Contrast Range** | %.3f |\n",
		stats.ChromaticDiversity, stats.ContrastRange))
	readme.WriteString(fmt.Sprintf("| **Primary Hue** | %.0f° | **Hue Variance** | %.1f° |\n",
		stats.PrimaryHue, stats.HueVariance))
	readme.WriteString(fmt.Sprintf("| **Lightness Spread** | %.3f | **Saturation Spread** | %.3f |\n",
		stats.LightnessSpread, stats.SaturationSpread))
	readme.WriteString(fmt.Sprintf("| **Total Colors** | %d | **Total Pixels** | %d |\n",
		profile.Pool.UniqueColors, profile.Pool.TotalPixels))
	
	readme.WriteString("\n")
}

func writeProfileAnalysis(readme *strings.Builder, profile *processor.ColorProfile) {
	readme.WriteString("### Profile Analysis\n\n")
	readme.WriteString("| Property | Value | Description |\n")
	readme.WriteString("|----------|-------|-------------|\n")

	readme.WriteString(fmt.Sprintf("| Mode | %s | Theme mode based on average luminance |\n", profile.Mode))
	readme.WriteString(fmt.Sprintf("| Dominant Hue | %.1f° | Most frequent hue direction |\n", profile.DominantHue))
	readme.WriteString(fmt.Sprintf("| Hue Variance | %.1f° | Color hue spread |\n", profile.HueVariance))
	readme.WriteString(fmt.Sprintf("| Average Luminance | %.3f | Overall brightness |\n", profile.AvgLuminance))
	readme.WriteString(fmt.Sprintf("| Average Saturation | %.3f | Overall color intensity |\n", profile.AvgSaturation))
	readme.WriteString(fmt.Sprintf("| Grayscale? | %t | Low saturation dominance |\n", profile.IsGrayscale))
	readme.WriteString(fmt.Sprintf("| Monochromatic? | %t | Single hue dominance |\n", profile.IsMonochromatic))
	readme.WriteString(fmt.Sprintf("| Total Colors | %d | Unique colors extracted |\n", profile.Pool.UniqueColors))
	readme.WriteString(fmt.Sprintf("| Total Pixels | %d | Image size processed |\n", profile.Pool.TotalPixels))

	readme.WriteString("\n")
}

// writeProfileSummary creates a concise profile overview
func writeProfileSummary(readme *strings.Builder, profile *processor.ColorProfile) {
	readme.WriteString("### Profile Overview\n\n")
	readme.WriteString("| Property | Value |\n")
	readme.WriteString("|----------|-------|\n")
	readme.WriteString(fmt.Sprintf("| **Theme Mode** | %s |\n", profile.Mode))
	readme.WriteString(fmt.Sprintf("| **Dominant Hue** | %.1f° |\n", profile.DominantHue))
	readme.WriteString(fmt.Sprintf("| **Average Luminance** | %.3f |\n", profile.AvgLuminance))
	readme.WriteString(fmt.Sprintf("| **Average Saturation** | %.3f |\n", profile.AvgSaturation))
	readme.WriteString(fmt.Sprintf("| **Is Grayscale** | %t |\n", profile.IsGrayscale))
	readme.WriteString(fmt.Sprintf("| **Is Monochromatic** | %t |\n", profile.IsMonochromatic))
	readme.WriteString("\n")
}

// writeCharacteristicBreakdown shows detailed color organization
func writeCharacteristicBreakdown(readme *strings.Builder, profile *processor.ColorProfile, maxShown int) {
	readme.WriteString("### Characteristic Breakdown\n\n")
	
	// Lightness distribution
	writeLightnessGroups(readme, profile.Pool.ByLightness)
	
	// Saturation distribution
	writeSaturationGroups(readme, profile.Pool.BySaturation)
	
	// Hue families
	writeHueFamilies(readme, profile.Pool.ByHue)
	
	// Detailed color breakdown if requested
	writeDetailedColorBreakdown(readme, profile, maxShown)
}

// renderColorSwatch creates a compact color swatch for grid display
func renderColorSwatch(hexColor string) string {
	// Remove # prefix if present for URL formatting
	cleanHex := strings.TrimPrefix(hexColor, "#")

	// Validate hex format
	if len(cleanHex) != 6 {
		return "![invalid](https://placehold.co/20x20/cccccc/cccccc.png)"
	}

	// Return markdown image tag with placehold.co URL for small swatches
	return fmt.Sprintf("![%s](https://placehold.co/20x20/%s/%s.png)", hexColor, cleanHex, cleanHex)
}

// renderColorBlock creates an image tag for color preview using placehold.co
func renderColorBlock(hexColor string) string {
	// Remove # prefix if present for URL formatting
	cleanHex := strings.TrimPrefix(hexColor, "#")

	// Validate hex format
	if len(cleanHex) != 6 {
		return "![invalid](https://placehold.co/30x30/cccccc/cccccc.png)"
	}

	// Return markdown image tag with placehold.co URL
	return fmt.Sprintf("![%s](https://placehold.co/30x30/%s/%s.png)", hexColor, cleanHex, cleanHex)
}
