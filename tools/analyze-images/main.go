package main

import (
	"context"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/JaimeStill/omarchy-theme-generator/pkg/formats"
	"github.com/JaimeStill/omarchy-theme-generator/pkg/loader"
	"github.com/JaimeStill/omarchy-theme-generator/pkg/processor"
	"github.com/JaimeStill/omarchy-theme-generator/pkg/settings"
)

func main() {
	// Parse command line flags
	imagesDir := flag.String("images", "tests/images", "Directory containing test images")
	flag.Parse()

	// Find all image files
	entries, err := os.ReadDir(*imagesDir)
	if err != nil {
		fmt.Printf("Error reading directory: %v\n", err)
		return
	}

	var images []string
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		name := entry.Name()
		ext := strings.ToLower(filepath.Ext(name))
		if ext == ".jpg" || ext == ".jpeg" || ext == ".png" {
			images = append(images, name)
		}
	}

	sort.Strings(images)

	// Initialize processor
	s := settings.DefaultSettings()
	p := processor.New(s)
	l := loader.NewFileLoader(s)
	ctx := context.Background()

	// Start building README content
	var readme strings.Builder
	readme.WriteString("# Test Images Analysis\n\n")
	readme.WriteString("This document provides detailed color analysis of all test images using the sophisticated 27-category extraction system. ")
	readme.WriteString("Each image is processed through the category-based color extraction pipeline with multi-dimensional scoring.\n\n")
	readme.WriteString("Generated by `go run tools/analyze-images/main.go`\n\n")

	for _, imageName := range images {
		imagePath := filepath.Join(*imagesDir, imageName)

		// Load image
		img, err := l.LoadImage(ctx, imagePath)
		if err != nil {
			readme.WriteString(fmt.Sprintf("## %s\n\n", imageName))
			readme.WriteString(fmt.Sprintf("**Error loading image**: %v\n\n", err))
			continue
		}

		// Get image info
		info, err := l.GetImageInfo(ctx, imagePath)
		if err != nil {
			readme.WriteString(fmt.Sprintf("## %s\n\n", imageName))
			readme.WriteString(fmt.Sprintf("**Error getting image info**: %v\n\n", err))
			continue
		}

		// Process image for complete analysis
		profile, err := p.ProcessImage(img)
		if err != nil {
			readme.WriteString(fmt.Sprintf("## %s\n\n", imageName))
			readme.WriteString(fmt.Sprintf("**Error processing image**: %v\n\n", err))
			continue
		}

		// Write image section header
		readme.WriteString(fmt.Sprintf("## %s\n\n", imageName))
		readme.WriteString(fmt.Sprintf("![%s](./%s)\n\n", imageName, imageName))
		readme.WriteString(fmt.Sprintf("**Dimensions**: %d x %d px\n\n", info.Width, info.Height))

		// Category-based color analysis
		writeCategoryAnalysis(&readme, profile)

		// Core color summary for quick reference
		writeCoreSummary(&readme, profile)

		// Analysis metadata
		writeProfileAnalysis(&readme, profile)
	}

	// Write README to tests/images/README.md
	outputPath := filepath.Join(*imagesDir, "README.md")
	err = os.WriteFile(outputPath, []byte(readme.String()), 0644)
	if err != nil {
		fmt.Printf("Error writing README: %v\n", err)
		return
	}

	fmt.Printf("Successfully analyzed %d images and wrote README to %s\n", len(images), outputPath)
}

// writeCategoryAnalysis generates comprehensive category-based color analysis
func writeCategoryAnalysis(readme *strings.Builder, profile *processor.ColorProfile) {
	readme.WriteString("### Category Analysis\n\n")
	readme.WriteString(fmt.Sprintf("**Category Coverage**: %.1f%% (%d of %d categories)\n\n", 
		profile.Colors.CoverageRatio*100, 
		len(profile.Colors.Categories),
		len(processor.GetAllCategories())))

	// Core UI Elements
	writeCategorySection(readme, "Core UI Elements", profile, []processor.ColorCategory{
		processor.CategoryBackground,
		processor.CategoryForeground,
		processor.CategoryDimForeground,
		processor.CategoryCursor,
	})

	// Terminal Normal Colors
	writeCategorySection(readme, "Terminal Normal Colors (ANSI 0-7)", profile, []processor.ColorCategory{
		processor.CategoryNormalBlack,
		processor.CategoryNormalRed,
		processor.CategoryNormalGreen,
		processor.CategoryNormalYellow,
		processor.CategoryNormalBlue,
		processor.CategoryNormalMagenta,
		processor.CategoryNormalCyan,
		processor.CategoryNormalWhite,
	})

	// Terminal Bright Colors
	writeCategorySection(readme, "Terminal Bright Colors (ANSI 8-15)", profile, []processor.ColorCategory{
		processor.CategoryBrightBlack,
		processor.CategoryBrightRed,
		processor.CategoryBrightGreen,
		processor.CategoryBrightYellow,
		processor.CategoryBrightBlue,
		processor.CategoryBrightMagenta,
		processor.CategoryBrightCyan,
		processor.CategoryBrightWhite,
	})

	// Accent Colors
	writeCategorySection(readme, "Accent Colors", profile, []processor.ColorCategory{
		processor.CategoryAccentPrimary,
		processor.CategoryAccentSecondary,
		processor.CategoryAccentTertiary,
	})

	// Semantic Colors
	writeCategorySection(readme, "Semantic Colors", profile, []processor.ColorCategory{
		processor.CategoryError,
		processor.CategoryWarning,
		processor.CategorySuccess,
		processor.CategoryInfo,
	})
}

func writeCategorySection(readme *strings.Builder, title string, profile *processor.ColorProfile, categories []processor.ColorCategory) {
	// First, collect categories that actually have colors
	var validRows []string
	
	for _, category := range categories {
		if c, exists := profile.Colors.Categories[category]; exists {
			hex := formats.ToHex(c)
			visual := renderColorBlock(hex)
			candidateCount := 0
			if candidates, hasCandidates := profile.Colors.CategoryCandidates[category]; hasCandidates {
				candidateCount = len(candidates)
			}
			validRows = append(validRows, fmt.Sprintf("| %s | `%s` | %s | %d |\n", 
				string(category), hex, visual, candidateCount))
		}
		// Omit rows for categories without colors (empty table rows)
	}
	
	// Only write the section if there are valid rows
	if len(validRows) > 0 {
		readme.WriteString(fmt.Sprintf("#### %s\n\n", title))
		readme.WriteString("| Category | Hex | Visual | Candidates |\n")
		readme.WriteString("|----------|-----|--------|-----------|\n")
		
		for _, row := range validRows {
			readme.WriteString(row)
		}
		readme.WriteString("\n")
	}
}

func writeCoreSummary(readme *strings.Builder, profile *processor.ColorProfile) {
	// Show the most important colors for quick reference
	coreCategories := []struct{
		name string
		category processor.ColorCategory
	}{
		{"Background", processor.CategoryBackground},
		{"Foreground", processor.CategoryForeground},
		{"Primary Accent", processor.CategoryAccentPrimary},
		{"Error", processor.CategoryError},
		{"Success", processor.CategorySuccess},
	}

	// First, collect categories that actually have colors
	var validRows []string
	
	for _, core := range coreCategories {
		if c, exists := profile.Colors.Categories[core.category]; exists {
			hex := formats.ToHex(c)
			visual := renderColorBlock(hex)
			validRows = append(validRows, fmt.Sprintf("| %s | `%s` | %s |\n", core.name, hex, visual))
		}
		// Omit rows for categories without colors (empty table rows)
	}
	
	// Only write the section if there are valid rows
	if len(validRows) > 0 {
		readme.WriteString("### Core Colors Summary\n\n")
		readme.WriteString("| Role | Hex | Visual |\n")
		readme.WriteString("|------|-----|--------|\n")
		
		for _, row := range validRows {
			readme.WriteString(row)
		}
		readme.WriteString("\n")
	}
}

func writeProfileAnalysis(readme *strings.Builder, profile *processor.ColorProfile) {
	readme.WriteString("### Profile Analysis\n\n")
	readme.WriteString("| Property | Value |\n")
	readme.WriteString("|----------|-------|\n")

	readme.WriteString(fmt.Sprintf("| Mode | %s |\n", profile.Mode))
	readme.WriteString(fmt.Sprintf("| Color Scheme | %s |\n", profile.ColorScheme))
	readme.WriteString(fmt.Sprintf("| Dominant Hue | %.1f° |\n", profile.DominantHue))
	readme.WriteString(fmt.Sprintf("| Hue Variance | %.1f° |\n", profile.HueVariance))
	readme.WriteString(fmt.Sprintf("| Average Luminance | %.3f |\n", profile.AvgLuminance))
	readme.WriteString(fmt.Sprintf("| Average Saturation | %.3f |\n", profile.AvgSaturation))
	readme.WriteString(fmt.Sprintf("| Grayscale? | %t |\n", profile.IsGrayscale))
	readme.WriteString(fmt.Sprintf("| Monochromatic? | %t |\n", profile.IsMonochromatic))
	readme.WriteString(fmt.Sprintf("| Total Colors | %d |\n", profile.Colors.UniqueColors))
	readme.WriteString(fmt.Sprintf("| Total Pixels | %d |\n", profile.Colors.TotalPixels))

	readme.WriteString("\n")
}

// renderColorBlock creates a Unicode color block representation instead of HTML
func renderColorBlock(hexColor string) string {
	// Parse color to determine brightness for appropriate block character
	color, err := formats.ParseHex(hexColor)
	if err != nil {
		return "■"
	}
	
	// Calculate luminance to choose appropriate Unicode block
	luminance := 0.2126*float64(color.R) + 0.7152*float64(color.G) + 0.0722*float64(color.B)
	luminance /= 255.0
	
	// Choose block character based on luminance
	if luminance > 0.8 {
		return "⬜" // Light colored square
	} else if luminance > 0.5 {
		return "◻️" // Medium square  
	} else {
		return "⬛" // Dark colored square
	}
}